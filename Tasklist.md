### **Итерационный план разработки: "Автоматизированный склад"**

**Общая продолжительность:** 7 недель (49 дней)
**Ресурс:** 1 разработчик

---

### **Итерация 1: Неделя 1-2 — Фундамент и первая связь**
**Цель:** Добиться, чтобы клиент (Unity) успешно получил данные от сервера (Flask). Это самый важный и рискованный этап, который нужно пройти как можно раньше.

-   [ ] **Общее:** Настроить Git-репозиторий с монорепозиторной структурой (`server/`, `client/`).
-   [ ] **Сервер (Backend):** Создать минимальное Flask-приложение.
-   [ ] **Сервер (Backend):** Реализовать один API-метод `GET /api/layout`, который возвращает "захардкоженный" (временно вписанный в код) JSON с размерами склада и одним роботом.
-   [ ] **Сервер (Backend):** Настроить `Flask-CORS`, чтобы разрешить запросы от будущего WebGL-клиента.
-   [ ] **Клиент (Frontend):** Создать пустой проект в Unity.
-   [ ] **Клиент (Frontend):** Написать C#-скрипт (`APIService`), который при старте отправляет запрос на `GET /api/layout` и выводит полученный JSON в консоль Unity.
-   [ ] **Клиент (Frontend):** В APIService реализовать обработку сетевых ошибок (try-catch) и таймаутов.
-   [ ] **Клиент (Frontend):** Создать базовый UI-элемент (например, всплывающее окно) для отображения сообщений об ошибках ( "Не удалось подключиться к серверу").
-   [ ] **Клиент (Frontend):** Реализовать проверку кода ответа HTTP и корректности десериализации JSON.
-   [ ] **Клиент (Frontend):** Реализовать загрузку URL сервера из внешнего файла config.json при старте приложения, а не хранить его в коде.
-   [ ] **Тестирование:** Запустить сервер и клиент. **Результат:** в консоли Unity должен появиться JSON, отправленный сервером.

---

### **Итерация 2: Неделя 3 — Визуализация статичного мира**
**Цель:** Динамически построить 3D-сцену на клиенте на основе данных, полученных от сервера.

-   [ ] **Сервер (Backend):** Перенести конфигурацию склада из кода в файл `default_warehouse.json`. Сервер при старте должен читать этот файл.
-   [ ] **Сервер (Backend):** Расширить JSON в `GET /api/layout`, добавив в него массив статических объектов (стеллажей).
-   [ ] **Клиент (Frontend):** Создать C#-классы-модели (`GridData`, `RobotData`, `ShelfData`) для десериализации ответа от сервера.
-   [ ] **Клиент (Frontend):** Создать простые 3D-префабы: "ПлиткаПола", "Робот" (куб), "Стеллаж" (параллелепипед).
-   [ ] **Клиент (Frontend):** Написать `SceneBuilder.cs`, который после получения данных от `/api/layout` генерирует сцену: создает сетку из префабов "ПлиткаПола" и расставляет роботов и стеллажи в начальных позициях.
-   [ ] **Тестирование:** Запустить сервер и клиент. **Результат:** на экране отображается 3D-сцена склада, полностью соответствующая конфигурации в `default_warehouse.json`.

---

### **Итерация 3: Неделя 4-5 — Оживление роботов (Завершение MVP)**
**Цель:** Реализовать постоянное обновление состояния и плавное движение объектов, завершив тем самым MVP.

-   [ ] **Сервер (Backend):** Реализовать ядро симуляции (`SimulationEngine`) в отдельном фоновом потоке, как описано в архитектуре.
-   [ ] **Сервер (Backend):** В цикле симуляции реализовать простую логику: мгновенное изменение координат роботов (например, движение к случайной точке).
-   [ ] **Сервер (Backend):** Реализовать API-метод `GET /api/state`, который потокобезопасно возвращает текущие координаты всех роботов.
-   [ ] **Клиент (Frontend):** Реализовать механизм опроса (polling): `SimulationController` должен раз в секунду вызывать `GET /api/state`.
-   [ ] **Клиент (Frontend):** Реализовать плавную анимацию. Скрипт робота (`RobotView.cs`) должен не телепортировать модель, а плавно перемещать ее из старой позиции в новую с помощью `Vector3.Lerp` или `Vector3.MoveTowards`.
-   [ ] **Тестирование:** Запустить систему. **Результат:** роботы плавно перемещаются по складу, их движение полностью управляется сервером. MVP готов.

---

### **Итерация 4: Неделя 6 — Интеллектуальное движение**
**Цель:** Научить роботов обходить препятствия.

-   [ ] **Сервер (Backend):** Реализовать базовый алгоритм поиска пути A* в `PathFinder.py`. Входные данные: карта с препятствиями, старт, финиш. Выходные данные: список координат пути.
-   [ ] **Сервер (Backend):** Интегрировать A* в `SimulationEngine`. Теперь робот получает задачу (например, "добраться до точки X, Y"), движок строит маршрут и в каждом "тике" перемещает робота на следующую клетку маршрута.
-   [ ] **Клиент (Frontend):** (Опционально) Реализовать визуализацию пути для выбранного робота для упрощения отладки.
-   [ ] **Тестирование:** Задать роботу цель за препятствием. **Результат:** робот должен найти и проследовать по маршруту, огибая стеллаж, а не проходя сквозь него.
-   [ ] **Сервер (Backend):** Написать юнит-тесты для алгоритма A* (PathFinder.py), проверяющие корректность построения маршрутов в разных сценариях (с препятствиями, без пути и т.д.).

---

### **Итерация 5: Неделя 7 — Интерактивное управление**
**Цель:** Дать пользователю возможность управлять ходом симуляции и получать информацию об объектах.

-   [ ] **Клиент (Frontend):** Создать базовый UI в Unity: кнопки "Пауза", "Старт".
-   [ ] **Сервер (Backend):** Реализовать API-методы `POST /api/simulation/pause` и `POST /api/simulation/start`, которые управляют состоянием `SimulationEngine`.
-   [ ] **Клиент (Frontend):** Связать кнопки UI с новыми API-методами.
-   [ ] **Клиент (Frontend):** Реализовать механику клика по объекту (Raycast).
-   [ ] **Клиент (Frontend):** При клике на робота или стеллаж отображать UI-панель с его ID и текущими координатами.
-   [ ] **Тестирование:** Запустить симуляцию. **Результат:** пользователь может ставить симуляцию на паузу, возобновлять ее и просматривать информацию о любом объекте на сцене.

---

### **Итерация 6: Неделя 8-9 — Базовая логика WMS**
**Цель:** Перейти от случайного движения к осмысленным задачам, имитирующим работу склада.

-   [ ] **Сервер (Backend):** Расширить модели данных: `Task`, `Order`.
-   [ ] **Сервер (Backend):** Создать простой менеджер задач (`TaskManager.py`), который генерирует последовательность задач для роботов (например, "взять груз из ячейки А, доставить в зону Б").
-   [ ] **Сервер (Backend):** Изменить логику `SimulationEngine`: свободный робот запрашивает у `TaskManager` новую задачу и начинает ее выполнять.
-   [ ] **Сервер (Backend):** Расширить `GET /api/state` для передачи информации о текущей задаче робота.
-   [ ] **Клиент (Frontend):** Добавить визуальную индикацию для отображения статуса робота (например, изменить цвет, если он выполняет задачу) и цели его движения.
-   [ ] **Тестирование:** Запустить симуляцию. **Результат:** роботы больше не движутся хаотично, а выполняют осмысленную цепочку задач, имитируя рабочий процесс.
-   [ ] **Сервер (Backend):** Написать юнит-тесты для TaskManager.py, проверяющие логику создания и распределения задач.

---

### **Итерация 7: Неделя 10-11 — Развертывание и документация**
**Цель:** Упаковать проект так, чтобы любой человек мог легко его запустить и посмотреть.

-   [ ] **Сервер (Backend):** Написать `Dockerfile` и `docker-compose.yml` для упаковки серверного приложения.
-   [ ] **Сервер (Backend):** Протестировать запуск сервера локально с помощью команды `docker-compose up`.
-   [ ] **Клиент (Frontend):** Настроить и выполнить сборку проекта под платформу WebGL.
-   [ ] **Клиент (Frontend):** "Запечь" в сборку публичный URL сервера (если он будет, иначе — инструкцию по использованию `localhost`).
-   [ ] **Развертывание:** Настроить GitHub Pages и выгрузить WebGL-сборку.
-   [ ] **Документация:** Финализировать `README.md`. Добавить краткое описание, скриншот проекта и четкие инструкции "Getting Started" для запуска сервера и ссылку на клиент на GitHub Pages.
-   [ ] **Тестирование:** Попросить друга или коллегу (или сделать самому в "чистой" среде) выполнить шаги из `README.md`. **Результат:** проект успешно запускается и работает.