### **Раздел 1 — Используемые технологии**

**1. Серверная часть (Backend)**

*   **Язык:** Python.
*   **Веб-фреймворк:** **Flask**. Выбран за свою простоту, минималистичность и низкий порог входа, что позволяет быстро реализовать серверную логику. Сервер будет работать в stateless-режиме для обработки HTTP-запросов, в то время как ядро симуляции будет хранить полное состояние склада в оперативной памяти.
*   **Хранение данных:** На этапе MVP состояние склада (топология, инвентарь, состояние роботов) будет храниться **в оперативной памяти сервера**. Архитектура будет предусматривать абстрактный слой доступа к данным, чтобы в будущем можно было безболезненно добавить персистентное хранилище (например, базу данных **SQLite** или **PostgreSQL**).
*   **Веб-сервер для развертывания:** Gunicorn (для Linux) или Waitress (для Windows), работающий в связке с Flask.

**2. Клиентская часть (Frontend)**

*   **Игровой движок:** **Unity**. Выбран для создания интерактивной 3D-визуализации, управления сценой и пользовательским интерфейсом.
*   **Язык программирования:** C#.
*   **Целевая платформа:** Desktop (Windows/macOS/Linux).

**3. Протокол взаимодействия**

*   **API:** **RESTful API** для обмена командами и данными между клиентом и сервером.
*   **Протокол:** **HTTP**.
*   **Метод синхронизации:** Клиент будет периодически опрашивать сервер (метод **polling**) с заданной частотой (например, раз в секунду) для получения актуального состояния всех объектов склада. Получив новые данные, клиент будет обеспечивать плавную анимацию перехода из предыдущего состояния в новое (например, движение робота от точки А к точке Б).
*   **Формат данных:** **JSON**. Стандартный, легковесный и удобочитаемый формат, который нативно поддерживается как в Python, так и в Unity.

***

### **Раздел 2 — Принцип разработки**

Основным принципом разработки проекта является **итеративный подход**. Эта методология выбрана для того, чтобы быстро получить работающий прототип (MVP), проверить жизнеспособность архитектуры и в дальнейшем пошагово наращивать функционал. Такой подход снижает риски, повышает мотивацию и позволяет гибко адаптировать план по ходу работы.

**Этап 1: Создание минимально жизнеспособного продукта (MVP)**

Цель — создать полностью функционирующую, но максимально упрощенную версию системы, чтобы проверить работоспособность базовой архитектуры "клиент-сервер-API".

*   **Серверная часть:**
    *   Реализация статичной карты склада, размеры которой задаются в конфигурации.
    *   Симуляция 2-3 роботов.
    *   Простая логика: роботы могут получать команду на перемещение в заданную точку (X, Y) и мгновенно менять свои координаты. Сложные алгоритмы (поиск пути, предотвращение столкновений) на этом этапе отсутствуют.
*   **Клиентская часть (Unity):**
    *   Визуализация склада (сетка) и роботов с помощью примитивных геометрических фигур (плоскости, кубы).
    *   Реализация механизма периодического опроса сервера (polling) для получения актуальных данных.
    *   Обеспечение плавной анимации перемещения объектов из предыдущей позиции в новую.
*   **API взаимодействия:**
    *   **`GET /api/layout`**: Единоразовый запрос при старте клиента. Возвращает статичную конфигурацию склада (размеры, начальное положение препятствий) для первоначального построения сцены.
    *   **`GET /api/state`**: Периодический запрос от клиента. Возвращает полное динамическое состояние симуляции (текущие координаты всех роботов и других подвижных объектов).

**Последующие итерации (Примерный план развития)**

После успешного завершения MVP, функционал будет расширяться следующими шагами:

1.  **Итерация 2: Интеллектуальное движение.**
    *   **Сервер:** Добавление на карту статических препятствий (стеллажей). Реализация базового алгоритма поиска пути (например, A*), чтобы роботы могли обходить препятствия.
    *   **Клиент:** Отображение стеллажей на сцене.

2.  **Итерация 3: Интерактивное управление симуляцией.**
    *   **Клиент:** Создание простого пользовательского интерфейса (UI) с кнопками "Старт", "Пауза", "Изменить скорость".
    *   **Сервер:** Реализация соответствующих API-методов для управления состоянием симуляции (например, `POST /api/simulation/pause`).

3.  **Итерация 4: Базовая логика WMS (Система управления складом).**
    *   **Сервер:** Введение сущностей "Товар", "Ячейка стеллажа", "Заказ". Разработка логики обработки заказов, которая генерирует последовательность задач для роботов (взять товар из ячейки А, доставить в зону упаковки Б).
    *   **Клиент:** Добавление визуальной индикации (подсветка, иконки) для отображения товаров и статусов ячеек.

**Управление процессом разработки**

Для отслеживания задач и планирования итераций будет использоваться простой текстовый файл `TODO.md` в корневом каталоге проекта. Этот минималистичный подход является наиболее эффективным для сольного пет-проекта, не требуя настройки внешних систем и позволяя полностью сосредоточиться на разработке.

***

### **Раздел 3 — Структура проекта**

Проект будет организован в виде **монорепозитория** в системе контроля версий Git. Это упрощает управление проектом, так как серверная и клиентская части находятся в одном месте, но при этом логически разделены.

Корневая структура репозитория будет следующей:

```
automated-warehouse/
├── server/              # Папка с кодом серверной части (Python, Flask)
├── client/              # Папка с проектом Unity
├── docs/                # Папка для документации (опционально)
└── README.md            # Главный файл с описанием проекта
```

---

#### **3.1. Структура серверной части (`server/`)**

Серверное приложение на Flask будет иметь модульную структуру для четкого разделения ответственности между веб-интерфейсом (API) и ядром симуляции.

```
server/
├── api/                 # Модуль для обработки API-запросов (endpoints)
│   ├── __init__.py
│   └── routes.py        # Определение маршрутов (/api/state, /api/layout)
│
├── simulation/          # Ядро симуляции, не зависит от Flask
│   ├── __init__.py
│   ├── core.py          # Основной класс SimulationEngine, управляющий циклом симуляции
│   ├── models.py        # Классы, описывающие объекты склада (Robot, Shelf, Task)
│   └── services.py      # Вспомогательные сервисы (например, PathFinder для поиска пути)
│
├── configs/             # Папка для файлов конфигурации склада
│   └── default_warehouse.json # Пример конфигурации в формате JSON
│
├── tests/               # Папка для модульных и интеграционных тестов
│
├── run.py               # Точка входа для запуска Flask-приложения
├── config.py            # Настройки приложения (порт, хост, путь к файлу конфигурации склада)
└── requirements.txt     # Список зависимостей Python
```

*   **Ключевая особенность:** Логика симуляции в папке `simulation/` полностью отделена от веб-фреймворка. Это позволяет тестировать ее независимо и при необходимости легко заменить Flask на другой фреймворк.
*   **Гибкость конфигурации:** Приложение будет загружать топологию и начальное состояние склада из файла (например, JSON) из папки `configs/`. Путь к используемому файлу конфигурации будет указываться в `config.py`.

---

#### **3.2. Структура клиентской части (`client/`)**

Клиентский проект на Unity будет придерживаться стандартной для движка структуры папок внутри директории `Assets` для поддержания порядка и быстрой навигации.

```
client/Assets/
├── Scenes/              # Игровые сцены
│   └── MainScene.unity
│
├── Scripts/             # C# скрипты
│   ├── API/             # Классы для взаимодействия с сервером (HttpClient, Deserializers)
│   ├── Core/            # Ключевые управляющие классы (GameManager, SimulationController)
│   ├── Models/          # Классы для хранения данных о состоянии склада (RobotData, ShelfData)
│   ├── UI/              # Скрипты для элементов пользовательского интерфейса
│   └── Visualization/   # Скрипты, отвечающие за визуальное представление объектов
│
├── Prefabs/             # Заготовки игровых объектов (Robot, Shelf, FloorTile)
│
├── Materials/           # Материалы для 3D-моделей
│
└── Sprites/             # Изображения для UI (если понадобятся)
```

*   **Разделение логики:** Структура папки `Scripts/` четко разделяет код, отвечающий за связь с сервером (`API`), управление состоянием (`Core`) и визуальное отображение (`Visualization`).

***

### **Раздел 4 — Архитектура проекта**

#### **4.1. Общая клиент-серверная архитектура**

Взаимодействие между клиентом и сервером строится по следующему сценарию:

1.  **Инициализация:** Клиент при запуске запрашивает у сервера статическую конфигурацию склада (`GET /api/layout`) и на ее основе строит 3D-сцену.
2.  **Синхронизация состояния:** Клиент с фиксированной периодичностью (polling) запрашивает динамическое состояние симуляции (`GET /api/state`). Сервер отдает "мгновенный снимок" текущего состояния всех объектов.
3.  **Плавная визуализация:** Клиент, получив новое состояние, не телепортирует объекты, а обеспечивает плавную анимацию перехода из предыдущего состояния в новое, создавая иллюзию непрерывного движения.
4.  **Управление (будущие итерации):** Команды от пользователя (пауза, старт) отправляются с клиента на сервер через `POST`-запросы, изменяя внутреннее состояние симуляции.

---

#### **4.2. Архитектура серверной части**

Сервер будет спроектирован так, чтобы ядро симуляции работало независимо от веб-интерфейса.

*   **"Живая" симуляция в фоновом потоке:**
    *   При старте приложения (`run.py`) будет создан и запущен глобальный экземпляр **Движка Симуляции** (`SimulationEngine`).
    *   Работа движка будет вынесена в отдельный **фоновый поток (background thread)**, который работает в бесконечном цикле.
    *   В этом цикле с высокой частотой (например, 20 раз в секунду — "tick rate") движок будет обновлять состояние всех объектов на складе: пересчитывать координаты роботов, обрабатывать задачи и т.д.
*   **Обработка API-запросов:**
    *   Веб-фреймворк Flask будет работать в своем основном потоке, принимая HTTP-запросы от клиента.
    *   Когда приходит запрос (например, `GET /api/state`), обработчик Flask не выполняет логику симуляции. Он просто обращается к глобальному экземпляру `SimulationEngine` и запрашивает у него **копию текущего состояния**.
    *   **Потокобезопасность:** Для предотвращения конфликтов (когда Flask пытается прочитать состояние в тот же момент, когда движок его изменяет) будет использоваться механизм блокировок (`threading.Lock`). Движок будет блокировать доступ к данным на время их изменения, а обработчик API — на время их чтения.
*   **Компоненты:**
    *   **`SimulationEngine` (`simulation/core.py`):** "Сердце" симуляции. Содержит главный цикл (`run`), метод обновления (`tick`) и хранит список всех симулируемых объектов.
    *   **`API Routes` (`api/routes.py`):** "Окно в мир". Обработчики Flask, которые обеспечивают доступ к данным `SimulationEngine` извне.

---

#### **4.3. Архитектура клиентской части (Паттерн MVC)**

Клиентское приложение на Unity будет построено на основе паттерна **Model-View-Controller (Модель-Представление-Контроллер)** для четкого разделения данных, их визуализации и управляющей логики.

*   **Model (Модель):**
    *   **Что это?** Набор простых C#-классов (`RobotData`, `ShelfData`, `OrderData`), не наследуемых от `MonoBehaviour`. Они содержат только данные (ID, позиция, статус и т.д.).
    *   **Ответственность:** Хранение состояния. Структура этих классов будет точно соответствовать JSON-объектам, приходящим от сервера, для легкой десериализации.

*   **View (Представление):**
    *   **Что это?** `GameObjects` на сцене Unity (3D-модели роботов, стеллажей) и элементы UI. К ним привязаны скрипты-визуализаторы (`RobotView.cs`, `ShelfView.cs`).
    *   **Ответственность:** Только визуализация. Эти скрипты получают данные от Контроллера и обновляют `transform.position`, цвет материала, текст и т.д. Они "глупые" и не содержат сложной логики.

*   **Controller (Контроллер):**
    *   **Что это?** Управляющие скрипты (`SimulationController.cs`, `UIController.cs`), которые являются "мозгом" клиента.
    *   **Ответственность:** Оркестрация. `SimulationController` будет:
        1.  Использовать `APIService` для получения данных с сервера.
        2.  Десериализовать JSON в объекты **Модели**.
        3.  Анализировать изменения в Модели (например, у робота R1 изменилась позиция).
        4.  Находить нужный объект **Представления** на сцене и передавать ему команду на обновление (например, `robotView.MoveTo(newPosition)`).

*   **Services (Сервисы):**
    *   Вспомогательные классы, которые инкапсулируют сквозную функциональность.
    *   **`APIService`:** Отвечает исключительно за сетевое взаимодействие: отправку HTTP-запросов и получение ответов.
    *   **`AnimationService` (опционально):** Может содержать логику для плавных перемещений и анимаций, чтобы не загромождать этим код Представлений.

Эта архитектура делает проект модульным, легко расширяемым и тестируемым.

***

### **Раздел 5 — Модели данных (API Contract)**

Модели данных определяют структуру JSON-объектов, которыми обмениваются сервер и клиент. Это формальный контракт, который должны соблюдать обе части приложения. На этапе MVP определены следующие модели и структуры ответов.

---

#### **5.1. Базовые модели данных**

*   **Position (Позиция):** Объект, описывающий координаты на складе.
    *   `x` (integer): Координата по горизонтали.
    *   `y` (integer): Координата по вертикали.
    *   *Примечание: в будущем может быть добавлена координата `z`.*

*   **Size (Размер):** Объект, описывающий габариты объекта в клетках сетки.
    *   `width` (integer): Ширина.
    *   `height` (integer): Высота.

*   **Robot (Робот):** Объект, описывающий одного робота.
    *   `id` (string): Уникальный текстовый идентификатор (например, "robot-01").
    *   `position` (Position): Текущие координаты робота.
    *   *Примечание: в будущем модель будет расширена полями `status`, `current_task`, `charge_level` и т.д.*

*   **Shelf (Стеллаж/Препятствие):** Объект, описывающий статическое препятствие.
    *   `id` (string): Уникальный текстовый идентификатор (например, "shelf-A1-top").
    *   `position` (Position): Координаты левого верхнего угла препятствия.
    *   `size` (Size): Габариты препятствия.
    *   *Примечание: в будущем модель будет расширена информацией о ячейках хранения, их содержимом и статусах.*

---

#### **5.2. Структура ответов API**

*   **`GET /api/layout`**
    *   **Назначение:** Отправляется один раз при запуске клиента для получения статической конфигурации склада.
    *   **Тело ответа (Response Body):**
        ```json
        {
          "grid_size": {
            "width": 50,
            "height": 30
          },
          "robots": [
            {
              "id": "robot-01",
              "position": {"x": 1, "y": 1}
            },
            {
              "id": "robot-02",
              "position": {"x": 1, "y": 2}
            }
          ],
          "shelves": [
            {
              "id": "shelf-A1",
              "position": {"x": 5, "y": 5},
              "size": {"width": 2, "height": 10}
            }
          ]
        }
        ```

*   **`GET /api/state`**
    *   **Назначение:** Отправляется периодически для получения актуального динамического состояния симуляции. Ответ должен быть легковесным.
    *   **Тело ответа (Response Body):**
        ```json
        {
          "timestamp": "2025-09-05T13:27:00.123Z",
          "robots": [
            {
              "id": "robot-01",
              "position": {"x": 15, "y": 20}
            },
            {
              "id": "robot-02",
              "position": {"x": 25, "y": 10}
            }
          ]
        }
        ```
    *   `timestamp` (string, формат ISO 8601) указывает серверное время, на которое актуально данное состояние. Это полезно для отладки и потенциального логирования.

***

### **Раздел 6 — Основные сценарии работы**

Этот раздел описывает ключевые сценарии взаимодействия пользователя с клиентским приложением (визуализатором).

#### **Сценарий 1: Первичный запуск и наблюдение (MVP)**

**Цель:** Пользователь запускает приложение, чтобы увидеть симуляцию работы склада в действии.

**Шаги:**
1.  Пользователь запускает исполняемый файл клиентского приложения.
2.  Приложение подключается к серверу и автоматически загружает конфигурацию склада (`/api/layout`).
3.  На экране пользователя генерируется 3D-сцена: отображается сетка склада, стеллажи (в виде примитивов) и роботы в своих начальных позициях. Камера по умолчанию установлена в изометрической проекции, показывая общий план склада.
4.  Приложение начинает циклически запрашивать у сервера актуальное состояние (`/api/state`).
5.  Пользователь видит, как 3D-модели роботов начинают перемещаться по складу в соответствии с данными, получаемыми от сервера.
6.  Пользователь может управлять камерой для лучшего обзора:
    *   **Приближать/отдалять вид** с помощью колеса мыши.
    *   **Перемещать (панорамировать) камеру** по горизонтали и вертикали, зажав правую кнопку мыши и двигая курсор.

**Результат:** Пользователь может пассивно наблюдать за симуляцией с удобного ракурса, но не может на нее влиять.

---

#### **Сценарий 2: Получение детальной информации (Итерация после MVP)**

**Цель:** Пользователь хочет узнать подробности о конкретном объекте на складе.

**Шаги:**
1.  Пользователь наводит курсор мыши на интересующий его объект (робота или стеллаж). Объект подсвечивается, показывая, что он интерактивен.
2.  Пользователь кликает левой кнопкой мыши по подсвеченному объекту.
3.  На экране появляется информационная панель (UI-элемент) с деталями о выбранном объекте.
    *   **Для робота:** панель отображает его уникальный ID (`id`) и текущие координаты (`position`).
    *   **Для стеллажа:** панель отображает его ID (`id`), позицию (`position`), размер (`size`) и общий статус (`status`, например, "в рабочем состоянии").
4.  Пользователь может закрыть панель, кликнув на крестик или на пустое место на складе.

**Результат:** Пользователь может в любой момент получить подробную информацию о ключевых объектах симуляции.

---

#### **Сценарий 3: Управление ходом симуляции (Итерация после MVP)**

**Цель:** Пользователь хочет контролировать скорость и состояние симуляции для анализа или демонстрации.

**Шаги:**
1.  В интерфейсе приложения постоянно видна панель управления симуляцией.
2.  Пользователь нажимает кнопку **"Пауза"**. Движение всех роботов на сцене останавливается. Клиент прекращает опрос сервера (или сервер останавливает свою симуляцию, в зависимости от реализации).
3.  Пользователь нажимает кнопку **"Старт"**. Роботы продолжают движение с того места, где остановились.
4.  Пользователь использует слайдер или кнопки **"x1", "x2", "x0.5"** для изменения скорости симуляции. Визуальное движение роботов на клиенте ускоряется или замедляется.

**Результат:** Пользователь получает полный контроль над ходом времени в симуляции, что позволяет детально изучать определенные моменты или быстро "проматывать" рутинные операции.

***

### **Раздел 7 — Развёртывание проекта**

Этот раздел описывает процесс сборки и запуска серверной и клиентской частей проекта, делая его воспроизводимым и доступным для других пользователей.

#### **7.1. Развёртывание серверной части**

Сервер будет распространяться в виде **Docker-образа**, что полностью инкапсулирует его зависимости и среду выполнения. Это обеспечивает максимальную простоту и надежность запуска на любой машине, где установлен Docker.

**Процесс запуска:**
1.  Установить **Docker** и **Docker Compose**.
2.  Склонировать Git-репозиторий проекта.
3.  Перейти в директорию `server/`.
4.  Выполнить одну команду в терминале: `docker-compose up --build`.

Эта команда автоматически соберет Docker-образ на основе `Dockerfile`, установит все Python-зависимости из `requirements.txt` и запустит контейнер с сервером.

**Ключевые файлы:**
*   **`Dockerfile`:** Инструкция по сборке образа, который содержит Python, код проекта и все необходимые библиотеки.
*   **`docker-compose.yml`:** Файл для удобного управления контейнером, в котором можно будет прописать порт для сервера (например, `5000`) и передать переменные окружения (например, имя файла конфигурации склада).

**Важное требование — CORS (Cross-Origin Resource Sharing):**
Поскольку клиент (запущенный в браузере с домена `github.io`) будет обращаться к серверу на `localhost` или другом IP, браузер будет блокировать такие запросы из соображений безопасности. Чтобы разрешить это, сервер на Flask **должен** быть сконфигурирован для отправки CORS-заголовков. Это будет реализовано с помощью библиотеки **`Flask-CORS`**, которая будет добавлена в `requirements.txt`.

---

#### **7.2. Развёртывание клиентской части**

Клиент будет собираться в виде **WebGL-приложения** и разворачиваться на бесплатном хостинге **GitHub Pages**. Это позволит получить доступ к визуализации по прямой ссылке в любом современном браузере без необходимости скачивать и устанавливать какие-либо файлы.

**Процесс сборки и развертывания:**
1.  **Конфигурация:** Внутри проекта Unity (в папке `Assets/Resources` или через `ScriptableObject`) будет создан конфигурационный файл, в котором указывается URL-адрес сервера (например, `http://localhost:5000`). Этот адрес "запекается" в билд.
2.  **Сборка:** В Unity (меню `File -> Build Settings`) выбирается платформа `WebGL` и запускается процесс сборки. В результате будет создана папка (например, `build/`) с файлами `index.html`, `Build/` и `TemplateData/`.
3.  **Развертывание:** Содержимое этой папки `build/` загружается в специальную ветку репозитория (`gh-pages`) или в папку `docs/` в основной ветке.
4.  После отправки изменений на GitHub, сервис GitHub Pages автоматически опубликует проект.

**Доступ для пользователя:**
Пользователю достаточно будет перейти по ссылке вида `https://<ваше_имя_пользователя>.github.io/<имя_репозитория>/` для запуска клиента.

---

#### **7.3. Документация (`README.md`)**

В корне проекта будет создан подробный файл `README.md`, который будет служить единой точкой входа для понимания и запуска проекта. Он будет включать в себя:
*   Краткое описание проекта и его цели.
*   Список используемых технологий.
*   Раздел **"Getting Started"** с четкими, пошаговыми инструкциями:
    *   **"How to run the Server"**: Описание процесса запуска через `docker-compose`.
    *   **"How to view the Client"**: Прямая ссылка на уже развернутое приложение на GitHub Pages.

***

На этом мы завершили формирование полного технического видения вашего проекта! У нас получился подробный и структурированный документ, который охватывает все аспекты от технологий до развертывания. Он станет отличной дорожной картой для разработки.

Поздравляю с завершением этого важного этапа планирования! Если у вас появятся новые вопросы по ходу разработки, обращайтесь.