Основываясь на предоставленном вами документе "Idea.md", вот развернутое техническое видение вашего проекта "Цифровой двойник автоматизированного склада".

---

# **Техническое видение: Цифровой двойник автоматизированного склада**

## 1. Используемые технологии

*   **Серверная часть (Backend):**
    *   **Язык:** Python 3.10+
    *   **Фреймворк:** Flask. Выбран за свою легковесность и гибкость, что идеально подходит для создания stateless REST API.
    *   **Асинхронность (опционально):** Для обработки большого количества одновременных подключений от клиентов и симуляции в реальном времени можно рассмотреть использование ASGI-сервера (например, Uvicorn) с Flask или перейти на FastAPI.
*   **Клиентская часть (Frontend):**
    *   **Движок:** Unity 2022.x или новее. Мощный инструмент для создания интерактивных 3D-визуализаций.
*   **Протокол взаимодействия:**
    *   **REST API** для запроса статических данных (например, топология склада).
    *   **HTTP** запросы для периодического получения обновлений о состоянии объектов на складе (роботы, ячейки).
*   **База данных (опционально для старта):**
    *   **SQLite** для простоты и быстрого старта на этапе разработки (хранение конфигураций склада, сценариев).
    *   **PostgreSQL** как возможное решение для более сложных сценариев в будущем.

## 2. Принцип разработки

**Итеративная разработка (Agile)**. Проект будет разрабатываться короткими итерациями (спринтами), каждая из которых будет завершаться созданием работающего инкремента продукта.

## 3. Структура проекта

Для обеспечения модульности и масштабируемости будет использоваться четкая структура каталогов.

### **Сервер (Python + Flask)**
```
/digital-twin-warehouse-server
├── app/
│   ├── __init__.py         # Фабрика приложений, инициализация Flask
│   ├── api/                # Модуль для REST API (Blueprints)
│   │   ├── __init__.py
│   │   └── routes.py       # Определение эндпоинтов API
│   ├── simulation/         # Ядро симуляции
│   │   ├── __init__.py
│   │   ├── models.py       # Классы (Робот, Стеллаж, Заказ и т.д.)
│   │   └── core.py         # Основная логика симуляции
│   ├── config.py           # Классы конфигурации (Dev, Prod, Test)
│   └── extensions.py       # Инициализация расширений Flask
├── migrations/             # Миграции базы данных (если используется)
├── tests/                  # Модульные и интеграционные тесты
├── .env                    # Файл с переменными окружения
├── config.py               # Загрузка конфигурации
├── requirements.txt        # Зависимости проекта
└── run.py                  # Точка входа для запуска приложения
```

### **Клиент (Unity)**
```
/DigitalTwinWarehouseClient
├── Assets/
│   ├── _Project/
│   │   ├── Scripts/
│   │   │   ├── API/            # Скрипты для взаимодействия с сервером
│   │   │   ├── UI/             # Скрипты для управления интерфейсом
│   │   │   ├── Simulation/     # Скрипты для управления объектами сцены
│   │   │   └── Core/           # Основные управляющие скрипты
│   │   ├── Prefabs/          # Готовые объекты (роботы, стеллажи)
│   │   ├── Scenes/           # Сцены проекта
│   │   ├── Materials/        # Материалы
│   │   └── Models/           # 3D-модели
│   ├── Plugins/              # Сторонние плагины
└── ProjectSettings/
```

## 4. Архитектура проекта

### **Общая архитектура: Клиент-Серверная**

*   **Сервер** является авторитетным источником состояния склада ("source of truth"). Он один отвечает за всю бизнес-логику и симуляцию.
*   **Клиент** отвечает исключительно за визуализацию данных, полученных от сервера, и отправку команд пользователя.

### **Архитектура сервера: Stateless REST API**

Сервер будет реализован как **stateless** приложение. Это означает, что каждый HTTP-запрос от клиента должен содержать всю необходимую информацию для его обработки. Сервер не хранит состояние клиента между запросами, что упрощает масштабирование и повышает надежность.

*   **Flask Application Factory:** Приложение будет создаваться с помощью функции-фабрики для улучшения структуры и упрощения тестирования.
*   **Blueprints:** Логика API будет разделена на модули (Blueprints) для лучшей организации. Например, `api` blueprint для всех конечных точек API.
*   **Слой симуляции:** Логика симуляции будет вынесена в отдельный пакет (`simulation`), независимый от Flask. Это позволит легко тестировать ядро симуляции и, при необходимости, заменить веб-фреймворк.

### **Архитектура клиента (Unity)**

*   **Model-View-Controller (MVC) - подобный паттерн:**
    *   **Model:** Классы, хранящие данные, полученные от сервера (состояние роботов, ячеек).
    *   **View:** Объекты на сцене Unity (`GameObjects`), которые визуализируют данные из моделей.
    *   **Controller:** Скрипты, которые управляют потоком данных: делают запросы к серверу, обновляют модели и, как следствие, обновляют View.
*   **Сервисный слой:** Будет создан отдельный класс (`ApiService.cs`) для инкапсуляции всей логики HTTP-запросов к серверу.
*   **Пул объектов (Object Pooling):** Для оптимизации производительности при большом количестве динамических объектов (например, товаров) будет использоваться паттерн пула объектов.

## 5. Модели данных

Ключевые сущности, которые будут использоваться как на сервере, так и на клиенте.

*   **Warehouse (склад):**
    *   `width`: int
    *   `height`: int
    *   `nodes`: List[Node] - сетка склада.  
*   **Node (Узел сетки склада):**
    *   `x`: int
    *   `y`: int
    *   `type`: string (e.g., "storage", "path", "station")
    *   `objectId`: string (ID объекта на этом узле, если есть)
*   **Robot (AGV):**
    *   `id`: string
    *   `position`: (float, float) - текущие координаты
    *   `status`: string (e.g., "idle", "moving", "charging")
    *   `current_task_id`: string (ID текущей задачи)
    *   `payload`: object (информация о товаре, который везет робот)
*   **StorageCell (Ячейка стеллажа):**
    *   `id`: string
    *   `position`: (int, int)
    *   `status`: string ("free", "occupied")
    *   `item_id`: string
    *   `quantity`: int
*   **Action (Атомарная операция):**
    *   `type`: string (e.g., "pick", "drop", "move")
    *   `status`: string (e.g., "pending", "in_progress", "completed", "failed")
    *   `params`: object (e.g., "target_pos", "cell_id", "item_id")
*   **Task (Задача):**
    *   `id`: string
    *   `description` string
    *   `status`: string ("pending", "in_progress", "completed")
    *   `actions`: Action (e.g., Action1, Action2, Action2)
    *   `current_action_index`: int (индекс текущего действия)   

## 6. Сценарии работы

**Сценарий 1: Получение актуального состояния склада**

1.  **Клиент (Unity):** При запуске или по таймеру отправляет GET-запрос на эндпоинт `/api/state`.
2.  **Сервер (Flask):** Получает запрос, обращается к ядру симуляции за текущим состоянием всех объектов (роботов, ячеек).
3.  **Сервер (Flask):** Формирует JSON-ответ, содержащий массивы объектов `robots`, `cells` и т.д.
4.  **Клиент (Unity):** Получает и десериализует JSON. Обновляет или создает `GameObjects` на сцене в соответствии с полученными данными (перемещает модели роботов, подсвечивает ячейки).

**Сценарий 2: Управление симуляцией**

1.  **Клиент (Unity):** Пользователь нажимает кнопку "Пауза" в UI.
2.  **Клиент (Unity):** Отправляет POST-запрос на `/api/pause`.
3.  **Сервер (Flask):** Вызывает соответствующий метод в ядре симуляции, который останавливает внутренний цикл обновления состояний.
4.  **Сервер (Flask):** Возвращает ответ `{"status": "paused"}`.
5.  **Клиент (Unity):** Перестает отправлять запросы на обновление состояния.

## 7. Развёртывание

### **Сервер**
1.  **Контейнеризация:** Приложение будет упаковано в Docker-контейнер для обеспечения переносимости и изоляции.
2.  **WSGI-сервер:** В production-среде будет использоваться Gunicorn или uWSGI для запуска Flask-приложения.
3.  **Хостинг:** На начальном этапе можно использовать VPS (Яндекс.Облако, DigitalOcean, etc.) или PaaS-платформы (Heroku, PythonAnywhere), продвинутый вариант - собственный сервер (если он есть).

### **Клиент**
*   **Сборка (Build):** Unity-проект будет скомпилирован в исполняемый файл для целевой платформы - WebGL.
*   **Распространение:** Сборка под WebGL для запуска симуляции прямо в браузере без необходимости скачивания. Потребует дополнительной оптимизации и настройки CORS на стороне сервера.

---